
# TCP통신 (장고 to 유니티)
### 스레드 코딩 시 알게된 점(while과 bool)
##### Threading 을 사용할 때  
##### 먼저, while True 쓰는 이유(스레딩돌릴려면)  
##### = while 문으로 무한루프로 돌려야 스레딩을 사용하는 이유가 된다.  
##### 그리고, bool값으로 check하는 이유(변화감지)  
##### = 스레딩을 사용하면 메인 스레드가 아니기때문에(?) 데이터 Receive하면, 그 값을 string이 아닌 값에 넣지 못함(싱글톤변수, Input Field에 못 넣었음)  
##### 그래서 값 들어온걸 감지하도록 bool로 감지하였음

Python Server와 Client는 [이 웹사이트를](https://www.neuralnine.com/tcp-chat-in-python/)  
Unity Client는 [이 웹사이트를](https://www.youtube.com/watch?v=y3FU6d_BpjI&ab_channel=%EA%B3%A0%EB%9D%BC%EB%8B%88TV-%EA%B2%8C%EC%9E%84%EA%B0%9C%EB%B0%9C%EC%B1%84%EB%84%90)

### 먼저 장고에 Server Socket 설정
##### 먼저, EC2에 TCP통신 할 수 있는 포트를 보안설정에서 열어준다.
##### 첫번째, 장고 views.py에 Server Socket 설정하고 이 함수를 urls.py에 연결한다.
```python
# views.py

def chatServer(request):
    # Connection Data
    #host = '15.165.171.194'
    port = 7777

    # Starting Server
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("", port))
    server.listen()

    # Lists For Clients and Their Nicknames
    clients = []
    nicknames = []

    # Sending Messages To All Connected Clients
    def broadcast(message):
        for client in clients:
            client.send(message)

    # Handling Messages From Clients
    def handle(client):
        while True:
            try:
                # Broadcasting Messages
                message = client.recv(1024)
                broadcast(message)
            except:
                # Removing And Closing Clients
                index = clients.index(client)
                clients.remove(client)
                client.close()
                nickname = nicknames[index]
                broadcast('{} left!'.format(nickname).encode('ascii'))
                nicknames.remove(nickname)
                break

    # Receiving / Listening Function
    def receive():
        while True:
            # Accept Connection
            client, address = server.accept()
            print("Connected with {}".format(str(address)))

            # Request And Store Nickname
            client.send('NICK'.encode('ascii'))
            nickname = client.recv(1024).decode('ascii')
            nicknames.append(nickname)
            clients.append(client)

            # Print And Broadcast Nickname
            print("Nickname is {}".format(nickname))
            broadcast("{} joined!".format(nickname).encode('ascii'))
            client.send('Connected to server!'.encode('ascii'))

            # Start Handling Thread For Client
            thread = threading.Thread(target=handle, args=(client,))
            thread.start()

    receive()
    message = "수 하나를 입력해주세요."
    return HttpResponse(message)
```
##### 두번째, Unity Server에 Server Socket 설정하고 이 함수를 urls.py에 연결한다.
```cs
# client.cs

using UnityEngine;
using UnityEngine.UI;
using System.Net.Sockets;
using System.IO;
using System;
using System.Net;
using System.Text;
using System.Threading;


public class Client : MonoBehaviour
{
	public InputField inputMsg;
	public Text ChatText;

	private string msg;
	private string msg2;
	private bool checkReceived = false;
	string s;

	static Socket sock;



	private void Start()
    {
		ConnectToServer();

		//Thread writeThread = new Thread(new ThreadStart(Write));
		//writeThread.Start();
		Thread receiveThread = new Thread(new ThreadStart(Receive));
		receiveThread.Start();
	}

	public void ConnectToServer()
	{
		sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
		IPEndPoint localEndPoint = new IPEndPoint(IPAddress.Parse("15.165.171.194"), 7777);

		try
		{
			sock.Connect(localEndPoint);
		}
		catch
		{
			Debug.Log("Unable to connect to remote endpoint!");
		}
	}

	void Update()
	{
		if (Input.GetKeyDown(KeyCode.Return))
		{
			Write();
			//Chat.instance.ShowMessage(msg);
		}
		if(checkReceived)
        {
			ChatText.text += s;
			ChatText.text += "\n";
			checkReceived = false;
		}
	}

	void Write()
    {
		msg = inputMsg.text;

		if (msg != null)
        {
			string text = msg;
			byte[] data = Encoding.ASCII.GetBytes(text);
			sock.Send(data);
			Debug.Log("this tis message");
			inputMsg.text = "";
		}
	}

	void Receive()
    {
		while (true)
        {
			try
			{
				
				byte[] data = new byte[1024];
				int recv = sock.Receive(data);
				s = Encoding.ASCII.GetString(data, 0, recv);
				checkReceived = true;
				Debug.Log("sock.Receive : " + s);				
			}
			catch
			{
				Debug.Log("An error occured!");
				sock.Close();
			}
		}
	}

	void OnApplicationQuit()
	{
		CloseSocket();
	}

	void CloseSocket()
	{
		sock.Close();
	}
}
```
```cs
# chat.cs

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Chat : MonoBehaviour
{
    public static Chat instance;
	void Awake() => instance = this;

	public InputField InputMsg;
	public RectTransform ChatContent;
	public Text ChatText;
	public ScrollRect ChatScrollRect;


	public void ShowMessage(string data)
	{
		ChatText.text += ChatText.text == "" ? data : "\n" + data;
		
		Fit(ChatText.GetComponent<RectTransform>());
		Fit(ChatContent);
		Invoke("ScrollDelay", 0.03f);
	}

	void Fit(RectTransform Rect) => LayoutRebuilder.ForceRebuildLayoutImmediate(Rect);

	void ScrollDelay() => ChatScrollRect.verticalScrollbar.value = 0;
}
```

##### 파이썬에서 client socket 설정
```python
# client.py

import socket
import threading

# Choosing Nickname
nickname = input("Choose your nickname: ")

# Connecting To Server
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('15.165.171.194', 7777))

# Listening to Server and Sending Nickname
def receive():
    while True:
        try:
            # Receive Message From Server
            # If 'NICK' Send Nickname
            message = client.recv(1024).decode('ascii')
            if message == 'NICK':
                client.send(nickname.encode('ascii'))
            else:
                print(message)
        except:
            # Close Connection When Error
            print("An error occured!")
            client.close()
            break

# Sending Messages To Server
def write():
    while True:
        message = '{}: {}'.format(nickname, input(''))
        client.send(message.encode('ascii'))

# Starting Threads For Listening And Writing
receive_thread = threading.Thread(target=receive)
receive_thread.start()

write_thread = threading.Thread(target=write)
write_thread.start()
```






## 내가 구현하려는 TCP 통신의 조건
### 첫째, 서버소켓의 IP주소는 remote에 있어 고정 IP여야한다. 
### 둘째, 원격으로 서버 소켓 생성과 종료를 할 수 있어야한다.
### 셋째, C#과 python으로 통신되어야한다.

첫번째 조건을 위해, aws를 사용
두번째 조건을 위해, 원격으로 함수를 실행하여 소켓 생성 및 종료 할 수 있도록한다. (방법1:url 접속 시 함수 실행으로,,, 방법2: RPC를 사용한다.)  
셋번째 조건을 위해, 클라이언트(유니티)에서 "원격 함수 실행" 및 "클라이언트 소켓 생성과 종료" 할 수 있도록 한다.  

이제 만들어보자!
```
# urls.py(그냥 파일을 실행해도 되겠구나 

path('chatserver/', views.openTCPServer),

또는 server.py를 만들고 이렇게 실행! 테스트 필요!!

path('chatserver/', server),

```
```
# views.py

def openTCPServer()
  소켓 생성 바인드 리슨 커넥트 리씨브 센드 클로즈

```
```
# Unity


```














서버(파이썬)
```python
# server.py

import socket
import time
from datetime import datetime

HOST = '127.0.0.1' 
PORT = 8000       

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_socket.bind((HOST, PORT))

server_socket.listen()




client_socket, addr = server_socket.accept()

print('Connected by', addr)

k = 0

while True:
    
    msg = "first tcp messages " + str(k)
    client_socket.sendall(msg.encode())
    print('send 완료 '+ str(k) )
    k += 1
    time.sleep(2)
    if(k >= 5):
      client_socket.close()
      server_socket.close()
    
    '''
    무한 루프를 돌면서 2초에 한번씩 데이터를 송신함.
    만약 종료 조건을 넣고 싶다면 여기에 넣으면 됨
    '''

client_socket.close()
server_socket.close()
출처: https://run-a-way.tistory.com/63 [과제가 싫어서 도망쳐온 블로그:티스토리]
```

클라이언트(유니티)
```C#
# client.cs

using System.Collections;
using System.Collections.Generic;
using System.Net.Sockets;
using UnityEngine;
using System.Text;
using System;
using System.IO;
using System.Runtime.InteropServices;

public class TCPManager : MonoBehaviour
{
    TcpClient client;
    string serverIP = "127.0.0.1";
    int port = 5000;
    byte[] receivedBuffer;
    StreamReader reader;
    bool socketReady = false;
    NetworkStream stream;


    // Start is called before the first frame update
    void Start()
    {
       CheckReceive();
    }

    // Update is called once per frame
    void Update()
    {
        
        if(socketReady)
        {
            
            
            if (stream.DataAvailable)
            {
                receivedBuffer = new byte[100];
                stream.Read(receivedBuffer, 0, receivedBuffer.Length); // stream에 있던 바이트배열 내려서 새로 선언한 바이트배열에 넣기
                string msg = Encoding.UTF8.GetString(receivedBuffer, 0, receivedBuffer.Length); // byte[] to string
                Debug.Log(msg);
            }
            
        }
    }

    void CheckReceive()
    {
        if (socketReady) return;
        try
        {
            client = new TcpClient(serverIP, port);

            if (client.Connected)
            {                
                stream = client.GetStream();
                Debug.Log("Connect Success");
                socketReady = true;
            }
            
        }
        catch (Exception e)
        {
            Debug.Log("On client connect exception " + e);
        }

    }

    void OnApplicationQuit()
    {
        CloseSocket();
    }

    void CloseSocket()
    {
        if (!socketReady) return;

        reader.Close();
        client.Close();
        socketReady = false;
    }

}
출처: https://run-a-way.tistory.com/63 [과제가 싫어서 도망쳐온 블로그:티스토리]
```
